#include "Assets/Lib/noiseSimplex.cginc"

#pragma kernel Init
#pragma kernel Update
#pragma kernel FlipUpdate
//#pragma kernel Debug

struct Cell
{
    int Alive;
    int FlipAlive;
    
    int GetAlive(const bool flip)
    {
        return flip ? FlipAlive : Alive;
    }
    
    void SetAlive(const bool flip, int value)
    {
        if(flip)
            FlipAlive = value;
        else
            Alive = value;
    }
};

RWStructuredBuffer<Cell> BufferCells;

int Size;
float Chance;

RWStructuredBuffer<int> debug;

RWTexture2D<float4> Rendered;
RWTexture2D<float4> Heatmap;

/*float rand(in float2 uv)
{
    float2 noise = (frac(sin(dot(uv, float2(12.9898, 78.233) * 2.0)) * 43758.5453));
    return abs(noise.x + noise.y) * 0.5;
}*/

int index(in int x, in int y)
{
    return (x + 1) * (Size + 2) + y + 1;
}

uint count_neighbors(in int i, const bool flip)
{
    int n = 0;
    
    //For cells that were already updated, we neet to check their past value
    //And for cells that were not updated yet, we neet to check their current value
    n += BufferCells[i - Size - 3].GetAlive(flip);
    n += BufferCells[i - Size - 2].GetAlive(flip);
    n += BufferCells[i - Size - 1].GetAlive(flip);
    n += BufferCells[i - 1].GetAlive(flip);
    n += BufferCells[i + 1].GetAlive(flip);
    n += BufferCells[i + Size + 1].GetAlive(flip);
    n += BufferCells[i + Size + 2].GetAlive(flip);
    n += BufferCells[i + Size + 3].GetAlive(flip);
    
    return n;
}

void update(uint3 id, const bool flip)
{
    //We always display the results of the calculations in the last frame
    //And calculate values for the next frame
    //That's why what the user sees and what we refer to as the 'current frame' is actually the previous frame
    
    int i = index(id.x, id.y);
    Cell cell = BufferCells[i];
    
    const int lastFlip = !flip; //Find the flip of the last frame
    int wasAlive = cell.GetAlive(lastFlip); //Check if the cell was alive last frame
    int neighbors = count_neighbors(i, lastFlip); //Count the alive neighbors in the last frame
    
    //Render values from the last frame
    Rendered[id.xy] = wasAlive;
    //Heatmap[id.xy] = lerp(float4(0, 0, 1, 0), float4(1, 0, 0, 0), neighbors / float(8));
    
    //Calculate values for the next frame
    bool alive = (neighbors == 3) || (wasAlive && (neighbors == 2));
    cell.SetAlive(flip, alive);
    
    //Apply changes
    BufferCells[i] = cell;
    
    //debug
    debug[id.x * Size + id.y] = 100;
    Heatmap[id.xy + int2(1, 1)] = float4(1, id.z, 0, 0);
}

[numthreads(8, 8, 1)]
void Init(uint3 id : SV_DispatchThreadID)
{
    int i = index(id.x, id.y);
    
    Cell cell = BufferCells[i];
    
    //cell.Alive = rand(float2(id.x, id.y)) % 1 < Chance;
    Rendered[id.xy] = cell.Alive;
}

[numthreads(8, 8, 1)]
void Update(uint3 id : SV_DispatchThreadID)
{
    update(id, false);
}

[numthreads(8, 8, 1)]
void FlipUpdate(uint3 id : SV_DispatchThreadID)
{
    update(id, true);
}

/*[numthreads(8, 8, 1)]
void Debug(uint3 id : SV_DispatchThreadID)
{
    int i = index(id.x, id.y);
    
    Cell cell = BufferCells[i];
    
    Rendered[id.xy] = debug1(cell, id.x, id.y); //cell.Alive
    Heatmap[id.xy] = debug2(cell, id.x, id.y);
}*/