#pragma kernel Update
#pragma kernel FlipUpdate
#pragma kernel Randomise
#pragma kernel FlipRandomise
#pragma kernel SetPixels
#pragma kernel FlipSetPixels

struct Cell
{
    int Alive;
    int Neighbours;
};

RWStructuredBuffer<Cell> CellsBuffer;
RWStructuredBuffer<Cell> FlipCellsBuffer;

Buffer<int> Configurations;

int Size;
int Seed;
float Chance;

RWTexture2D<float4> Rendered;

Cell Get(const bool flip, int i)
{
    if (flip)
        return FlipCellsBuffer[i];
    else
        return CellsBuffer[i];
}

void Set(const bool flip, int i, Cell cell)
{
    if (flip)
        FlipCellsBuffer[i] = cell;
    else
        CellsBuffer[i] = cell;
}

void SetAlive(const bool flip, int i, bool alive)
{
    if (flip)
        FlipCellsBuffer[i].Alive = alive;
    else
        CellsBuffer[i].Alive = alive;
}

void SetNeighbours(const bool flip, int i, int value)
{
    if (flip)
        FlipCellsBuffer[i].Neighbours = value;
    else
        CellsBuffer[i].Neighbours = value;
}


void AddNeighbour(const bool flip, bool value, int i)
{
    if (flip)
        FlipCellsBuffer[i].Neighbours += value;
    else
        CellsBuffer[i].Neighbours += value;
}

// Hash function from H. Schechter & R. Bridson, goo.gl/RXiKaH
uint hash(uint s)
{
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return s;
}

float random(uint seed)
{
    return float(hash(seed)) / 4294967295.0; // 2^32-1
}

int index(in int x, in int y)
{
    return (x + 1) * (Size + 2) + y + 1;
}

void update_neighbours(const bool flip, in int i, bool value)
{
    AddNeighbour(flip, value, i - Size - 3);
    AddNeighbour(flip, value, i - Size - 2);
    AddNeighbour(flip, value, i - Size - 1);
    AddNeighbour(flip, value, i - 1);
    AddNeighbour(flip, value, i + 1);
    AddNeighbour(flip, value, i + Size + 1);
    AddNeighbour(flip, value, i + Size + 2);
    AddNeighbour(flip, value, i + Size + 3);
}

void update(uint3 id, const bool flip)
{
    int i = index(id.x, id.y);
    
    Cell lastCell = Get(!flip, i);
    
    bool alive = (lastCell.Neighbours == 3) || (lastCell.Alive && (lastCell.Neighbours == 2)); //Configurations[lastCell.Neighbours * 2 + lastCell.Alive];
    update_neighbours(flip, i, alive);
    
    SetAlive(flip, i, alive);
    SetNeighbours(!flip, i, 0);
    
    Rendered[id.xy] = alive;
}

void randomise(uint3 id, const bool flip)
{
    int i = index(id.x, id.y);
    
    bool alive = random(i + Seed) <= Chance;
    update_neighbours(flip, i, alive);
    
    SetAlive(flip, i, alive);
    SetNeighbours(!flip, i, 0);
    
    Rendered[id.xy] = alive;
}


[numthreads(8, 8, 1)]
void Randomise(uint3 id : SV_DispatchThreadID)
{
    randomise(id, false);
}

[numthreads(8, 8, 1)]
void FlipRandomise(uint3 id : SV_DispatchThreadID)
{
    randomise(id, true);
}


[numthreads(8, 8, 1)]
void Update(uint3 id : SV_DispatchThreadID)
{
    update(id, false);
}

[numthreads(8, 8, 1)]
void FlipUpdate(uint3 id : SV_DispatchThreadID)
{
    update(id, true);
}

int2 TargetPixel = int2(0, 0);

void setPixel(int2 offset, const bool flip)
{
    int2 pos = TargetPixel + offset;
    int i = index(pos.x, pos.y);
    SetAlive(flip, i, true);
    Rendered[pos] = true;
}

[numthreads(1, 1, 1)]
void SetPixels(uint3 id : SV_DispatchThreadID)
{
    setPixel(id.xy, false);
}

[numthreads(1, 1, 1)]
void FlipSetPixels(uint3 id : SV_DispatchThreadID)
{
    setPixel(id.xy, true);
}